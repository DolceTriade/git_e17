#!/usr/bin/env bash
# vim:expandtab:ts=4:sw=4:fdm=marker:fmr={{{,}}}
# To Inspect the code use vim, modelines and folds!!!!

#########################################################################
# This Scripts is inspired by Morlenxus' easy_e17.sh                    #
# and also a tiny bit of code is taken form it.                         #
# The easy_e17.sh script can be found at:                               #
# http://omicron.homeip.net/projects/#easy_e17.sh                       #
#                                                                       #
# License: BSD licence                                                  #
# Get the latest version at: https://github.com/ObiWahn/git_e17         #
# Coded by Jan Christoph Uhde (linux@obiwahn.org)                       #
#########################################################################

(( $BASH_VERSINFO < 4 )) && echo -e "\nThis Script requires at least bash version >= 4\n" && exit 1

### global variable definitions {{{
efl_basic="eina eet evas ecore efreet eio eeze e_dbus embryo edje azy ethumb elementary"
efl_extra="imlib2 emotion enlil libast python-evas python-ecore python-e_dbus python-edje python-emotion python-elementary shellementary"
bin_basic="exchange e"
bin_extra="e_cho e-type e_phys eblock econcentration editje eenvader.fractal elsa emote empower enjoy enki ephoto eskiss Eterm expedite exquisite eyelight rage terminology"
e_modules_efl="libeweather"
e_modules_bin="emprint exalt"
e_modules_extra="alarm calendar comp-scale cpu deskshow diskio drawer eektool elfe empris engage eooorg everything-aspell everything-mpris everything-pidgin everything-places everything-shotgun everything-skeleton everything-tracker everything-wallpaper everything-websearch eweather exalt-client exebuf execwatch flame forecasts iiirk itask mail mem moon mpdule net news penguins photo places quickaccess rain screenshot skel slideshow snow taskbar tclock uptime weather winlist-ng winselector wlan"
e_themes="darkness detourious efenniht"

packages_basic="$efl_basic $bin_basic $e_themes"
packages_half="$efl_basic $bin_basic $e_themes $e_modules_efl $e_modules_bin $e_modules_extra"
packages_full="$efl_basic $bin_basic $e_themes $e_modules_efl $e_modules_bin $e_modules_extra $efl_extra $bin_extra"

declare -A conf
declare -A g_old_conf

packages=""
packages_failed=""
g_current_commit=""
g_current_branch=""
g_old_commit=""

# signals return status of some operations as
# we lack proper return values
g_current_failed=false
g_clean_phase=false

conf[dev]=false
conf[verbose]=false
conf[debug]=false
conf[debug_level]=10
conf[animate]=false

conf[clean]=false
conf[distclean]=false
conf[uninstall]=false

#for use in errors
e="\n       "

bold=$(tput bold)
boldoff=$(tput sgr0)

conf[git_repo]=http://git.enlightenment.fr/cgit.cgi/svn.git/

###end global vars }}}
#### main function {{{
main(){
debug 1 "$FUNCNAME() $*"

## interpret command line
get_opts "$@"
list ## list available packages
## configuration
get_git_e17_path_from_global_cfg
read_local_cfg
read_global_cfg
assign_defaults
interpret_action
check_cfg
##
uninstall
## source
get_src
git_fetch_reset
git_pull
## package management
add_failed
ignore_pkgs
if ! [[ "$packages" ]]; then
    echo -e "\nNo packages to build!\n"
    exit 0
fi
## finding changes
calculate_updates
##
set_env
build
}
#### end main function }}}

##### functions used in main {{{
### display help - help(), devhelp() {{{
help(){
debug 1 "$FUNCNAME() $*"
#
# This functions displays the help file
#

printf '%b\n' \
   "git_e17 - simple script for building enlightenment 17" \
   "" \
   "git-e17 [options] action [only <packagelist>]" \
   "actions:" \
   "    check" \
   "        check if your system is ready to install e17" \
   "    build" \
   "        build everything" \
   "    update" \
   "        update your e17 to the latest version" \
   "    list" \
   "         list all available packages" \
   "    uninstall" \
   "        uninstall e17" \
   "" \
   "only:" \
   "     use only named packages" \
   "" \
   "options:" \
   "    -h | --help  / --dev-help" \
   "        show help / developer help" \
   "        developer help will give you some more options" \
   "    --git-e17-path" \
   "        workdir for this script. It will contain the source, config and log" \
   "        files and dirs in which e17 is build. The default git_e17_path sould" \
   "        be set in ~/.git_e17" \
   "    -i | --ignore pkg1,pkg2,pkg2" \
   "    -s | --skip-errors" \
   "        skip non fatal errors" \
   "    -a | --animate" \
   ""
}
devhelp(){
debug 1 "$FUNCNAME() $*"
#
# This functions displays the developer help file
#

printf '%b\n' \
   "extra actions:" \
   "    devupdate" \
   "        almost the same as update but does not imply --fetch-reset-hard" \
   "    fromscratch" \
   "        delete e17 installation and build e17 from scratch" \
   "        ATTENTION: this will rm -fr $install_path" \
   "                   do not do is if you installed to /usr/local" \
   "" \
   "extra options:" \
   "    --conf <conf>" \
   "        config file - especially useful if you want multiple installs" \
   "        ONLY CONF NAME - NO FULL PATHS!!!" \
   "    --cflags  flags" \
   "    --ldflags flags" \
   "        you need the quotes!!" \
   "    -b | --branch <branch>" \
   "        branch, tag or commit to use" \
   "    -r | --remote <remote>" \
   "        select remote pull/fetch" \
   "    -p | --pull" \
   "        does a git pull --no-commit" \
   "    -f | --fetch-reset-hard" \
   "        ATTENTION: this will delete your local changes!!!!" \
   "        fetches update from remote finds out your current branch" \
   "        and will do a git reset --hard remote/currentbrach" \
   "" \
   "    --clean / --distclean / --uninstall" \
   "        make clean / distclean before building" \
   "    --vmake" \
   "        more verbse make (V=1)" \
   "    --conf_args" \
   "        extra configure args - for all packages" \
   "    -v | --verbose" \
   "        be more verbose during the build" \
   "    -d | --debug" \
   "        enable script debugging mode"
}
### end help }}}

### parse command line
get_opts(){ #{{{
debug 1 "$FUNCNAME() $*"
section " reading command line options "
#
# This function reads the command line arguments
#
# In:
# $@ - ARGV
#
# Out:
# sets: conf, branch, debug, verbose or calls help
#
# TODO - idiot proof checking of arguments
#

copy_cfg

while :
do
    case $1 in
        --git-e17-path)
            conf[git_e17_path]="$2"
            echo "found option: --git-e17-path $2"
            shift 2
            ;;
        -c|--conf)
            conf[config_file]="$2"
            echo "found option: --conf $2"
            shift 2
            ;;
        -b|--branch)
            conf[branch]="$2"
            echo "found option: --branch $2"
            shift 2
            ;;
        -r|--remote)
            conf[remote]="$2"
            echo "found option: --remote $2"
            shift 2
            ;;
        -p|--pull)
            conf[pull]=true
            echo "found option: --pull"
            shift
            ;;
        -f|--fetch-reset-hard)
            conf[fetch]=true
            echo "found option: --fetch-reset-hard"
            shift
            ;;
        -s|--skip-errors)
            conf[on_error]=skip
            echo "found option: --skip-errors"
            shift
            ;;
        -a|--animate)
            conf[animate]=true
            conf[debug]=false
            conf[verbose]=false
            echo "found option: --animate"
            shift
            ;;
        -d|--debug)
            conf[debug]=true
            conf[animate]=false
            conf[debug_level]=4
            echo "found option: --debug"
            shift
            ;;
        -v|--verbose)
            conf[verbose]=true
            conf[animate]=false
            echo "found option: --verbose"
            shift
            ;;
        --cflags)
            conf[cflags]="$2"
            echo "found option: --cflags $2"
            shift 2
            ;;
        --ldflags)
            conf[ldflags]="$2"
            echo "found option: --ldflags $2"
            shift 2
            ;;
        --clean)
            conf[clean]=true
            echo "found option: --clean"
            shift
            ;;
        --distclean)
            conf[distclean]=true
            echo "found option: --distclean"
            shift
            ;;
        --uninstall)
            conf[uninstall]=true
            echo "found option: --uninstall"
            shift
            ;;
        -i | --ignore)
            conf[ignore]="$2"
            echo "found option: --ignore '$2'"
            shift 2
            ;;
        --dev-help)
            echo ""
            help
            echo "found option: --dev-help"
            devhelp
            exit 0
            ;;
        -h|--help)
            echo ""
            echo "found option: --help"
            help
            exit 0
            ;;
        *) #no more options beakb
            break
            ;;
    esac
done

#parse action parameter
debug 1 "action: $1"
if [[ "$1" == @(build|update|devupdate|fromscratch|list|uninstall) ]]; then
    conf[action]="$1"
    echo "selected action is ${conf[action]}"
    shift
else
    echo "Error: No vaild action"
    help
    exit 1
fi

if [[ "$1" == only ]]; then
    shift
    packages="$@"
    echo "only: $packages"
fi

echo
print_cfg
debug_cfg
} #}}}

### get git_e17_path form ~/.git_e17 || create the file
get_git_e17_path_from_global_cfg(){ #{{{
debug 1 "$FUNCNAME() $*"
section " reading global configuration in ~/.git_e17 "
#
#   This function tries to read the global configuration file
#   or creates it. If the file exists two important config
#   items are read when they are not set by command line
#
# Out:
#   sets: conf[git_e17_path], conf[config_file]
#
copy_cfg

local conf_file="$HOME/.git_e17"

debug 1 "git e17 path: $1"
if [[ ! -f "$conf_file" ]]; then
    #create config
    echo "$(default_global_cfg)" > "$conf_file" || ferr "Unable to create $conf_file"

    if [[ ! ${conf[git_e17_path]} ]]; then
        echo -e "\nPlease edit your fresh created ~/.git_e17\nand add the path to the default git e17 path."
    fi
fi

#read config values git_e17_path and config_file
while IFS='=' read -r item value; do
    if [[ "$item" == @(git_e17_path|config_file) ]]; then
        conf["$item"]=${conf["$item"]:-"$value"}
        debug 3 "conf[$item]=$value"
    fi
done <<< "$(grep -v ^# "$conf_file" | grep -v ^$ )"

#final check if path is set
debug 2 "The git e17 path must be set by now!! git_e17_path=${conf[git_e17_path]}"
if [[ ! ${conf[git_e17_path]} ]]; then
    ferr -e "git_e17_path is not set:(\n${e}please set it via commandline or ~/.git_e17"
fi

#remove trailing slash from git_e17_path
conf[git_e17_path]=${conf[git_e17_path]%/}

echo "git e17 path set to ${conf[git_e17_path]}"
echo "config file set to ${conf[config_file]}"

#check if git_e17_path exists
if ! [[ -d "${conf[git_e17_path]}" && -w "${conf[git_e17_path]}" ]]; then
    if ! mkdir -p "${conf[git_e17_path]}"; then
        ferr -e "unable to create or access ${conf[git_e17_path]}"
    fi
fi

echo
print_cfg
} #}}}

### read configuration in git e17 directory
read_local_cfg(){ #{{{
debug 1 "$FUNCNAME() $*"
section " reading git-e17-path configuration file (${conf[config_file]}) "
#
# This function reads the config file and sets script variables
#
# Out:
# sets: ... a lot ...
#
#

copy_cfg
local new_cfg=false
local conf_file="${conf[git_e17_path]}/${conf[config_file]}"
if [[ ! -f "$conf_file" ]]; then
    echo "$(default_local_cfg)" > "$conf_file" || ferr "Unable to create $conf_file"
    new_cfg=true
fi

# read config
config="$(grep -v ^# < "$conf_file" | grep -v ^$)"
debug 3 "$config"
while IFS='=' read -r item value; do
    conf["$item"]=${conf["$item"]:-"$value"}
done <<< "$config"

print_cfg

if $new_cfg; then
    echo -e "\nEnlightenment 17 will be install to: ${bold} ${conf[install_path]} ${boldoff}"
    echo -e "To change this or other settings you can edit:"
    echo -e "${bold}$conf_file${boldoff}\n"
    [[ $(ask_yn "Do you want to proceed with the installation using the defaults?") == "yes" ]] || exit 1
fi
} #}}}

### read rest of ~/.git_e17 - sets only overwrite unset options
read_global_cfg(){ #{{{
debug 1 "$FUNCNAME() $*"
section " reading global cfg options "
#
# add global configuration
#

copy_cfg

debug 1 "$FUNCNAME() $*"
    config="$(grep -v ^# < "$HOME/.git_e17" | grep -v ^$)"
    debug 3 "$config"
    while IFS='=' read -r item value; do
        conf["$item"]=${conf["$item"]:-"$value"}
    done <<< "$config"
print_cfg
}
### assign default values
assign_defaults(){
debug 1 "$FUNCNAME() $*"
section " assigning default vaules "

conf[log_path]="${conf[log_path]:-"${conf[git_e17_path]}/log"}"
conf[packagelist]="${conf[packagelist]:-"full"}"
conf[on_error]="${conf[on_error]:-"ask"}"
conf[nice]="${conf[nice]:-"19"}"
conf[pull]=${conf[pull]:-false}
conf[fetch]=${conf[fetch]:-false}
conf[remote]="${conf[remote]:-"origin"}"


if [[ ! $packages ]]; then
    case "${conf[packagelist]}" in
        full)  packages="$packages_full"  ;;
        half)  packages="$packages_half"  ;;
        basic) packages="$packages_basic" ;;
        *)     ferr "No valid package list packagelist=full|half|basic" ;;
    esac
fi
print_cfg
} #}}}

interpret_action(){
debug 1 "$FUNCNAME() $*"
local action="${conf[action]}"

case "$action" in
    build)
        conf[action]="build"
        conf[fetch]=false
        conf[pull]=false
        ;;
    update)
        conf[branch]="master"
        conf[remote]="origin"
        conf[fetch]=true
        conf[pull]=false
        conf[animate]=true
        conf[debug]=false
        conf[verbose]=false
        conf[on_error]="skip"
        ;;
    devupdate)
        conf[action]="update"
        ;;
    fromscratch)
        (( $(id -u) = 0 )) && echo "idiot!!!" && exit 666
        rm -fr "${conf[install_path]}"
        rm -fr "${conf[build_path]}"
        rm -fr "${conf[src_path]}/trunk"
        conf[fetch]=true
        conf[action]="update"
        ;;
    list)
        #TODO
        echo "not implemented"
        exit 1
        ;;

esac


}

### check for missing options and unwritable paths
check_cfg(){ #{{{
debug 1 "$FUNCNAME() $*"
#
# check configuration
#

## FIXME ##
conf[deto]="$HOME/.e/e/themes" ## FIX-FOR-A-THEME
local paths="deto install_path git_e17_path log_path src_path build_path log_path"
local output="debug debug_level dev verbose animate"
local conf_items="$paths $output action config_file packagelist nice on_error"

for item in $conf_items; do
    if [[ -z "${conf["$item"]}" ]]; then
        ferr "value for $item is not set - please edit your config file"
    fi
done

# check if directories are writeable
for path in $paths; do
    if [[ ! -d "${conf[$path]}" ]]; then
        mkdir -p "${conf[$path]}" && continue
        ferr "unable to create the directory ${conf[$path]} - create it!"
    elif [[ ! -w "${conf[$path]}" ]]; then
        ferr "The directory ${conf[$path]} is not writeable for you:( - change that!"
    fi
done

#translate strings to bool
for key in ${!conf[@]}; do
    case ${conf[key]} in
        true|yes) conf[key]=true ;;
        false|no) conf[key]=false ;;
        *) continue ;;
    esac
done
debug_cfg
} #}}}

### uninstall e17
uninstall(){ #{{{
debug 1 "$FUNCNAME() $*"
[[ ${conf[action]} == uninstall ]] || return
#
# This functions uninstalls e17
#
section " uninstalling e17 "

#
# ok this is is frigging ugly:P - but it works :E
#

#enter build dir
cd "${conf[build_path]}" || { echo "uninstall failed"; exit 1; }

for dir in * ; do
    #change dir
    if ! cd "$dir" &>/dev/null ; then
        echo "failed to uninstall $dir"
        continue
    fi
    #test for makefile
    if [[ -e Makefile || -e makefile ]]; then
        write_appname "$dir"
        #uninstall
        nice -n "${conf[nice]}" bash -c "make uninstall" &>>"${conf[log_path]}/uninstall.log" &
        rotate $! "" "${conf[log_path]}/uninstall.log"
        wait
        echo OK
    else
        echo FAILED
    fi
    cd ..
done
exit 0
} #}}}


### functions that scan source code and select packages to be build
### TODO SPLIT FUNCTION
get_src(){ #{{{
debug 1 "$FUNCNAME() $*"
section " getting source code "

g_current_failed=false
local src_path="${conf[src_path]}"
local git="${conf[git_repo]}"
local remote="${conf[remote]}"

rm -fr "${conf[git_e17_path]}/git.log"

#does the repo exist
if [[ ! -d ${conf[src_path]} ]]; then
    #create it
    echo "cloning ${conf[git_repo]}"
    git clone -v --progress "${conf[git_repo]}" "$src_path" || ferr "unable to clone repository"
fi
#change to repo
echo "changing into $src_path"
cd "$src_path" || ferr "failed to cd in $src_path"

#get name of branch
g_current_branch="$(git symbolic-ref HEAD)"
g_current_branch="${g_current_branch##*/}"
echo "Your current branch is $g_current_branch"

#get hash of current HEAD
g_old_commit="$(git log -1 --format="%H")"
echo "You are at commit $g_old_commit"

} #}}}

git_fetch_reset(){ #{{{
debug 1 "$FUNCNAME() $*"
${conf[fetch]} || return
section " git fetch  "

local remote="${conf[remote]}"
local branch="${conf[branch]:-"$g_current_branch"}"

#select right branch
echo "checking out $branch so that you local $branch matches the remote branch"
echo "i think this is a good requirement to save the average person from harm:) "
if [[ -n "$branch" && "$branch" != "$g_current_branch" ]]; then
    if ! git checkout ${conf[branch]}; then
        ferr "unable to checkout selected branch - fix your repository"
    fi
fi

echo "git fetch $remote"
git fetch $remote | tee -a "${conf[git_e17_path]}/git.log" || nerr "git fetch"

git clean -f -d &> /dev/null
echo "git reset --hard  $remote/$branch"
git reset --hard "$remote/$branch" | tee -a  "${conf[git_e17_path]}/git.log" || nerr "git reset --hard failed"

} #}}}

git_pull(){ #{{{
debug 1 "$FUNCNAME() $*"
${conf[pull]} || return
section " git pull --no-commit "
section " dear god we all hope there are no conflicts "
git pull --no-commit $remote | tee -a "${conf[git_e17_path]}/git.log" || nerr "git pull failed"
} #}}}

calculate_updates(){ #{{{
debug 1 "$FUNCNAME() $*"
[[ "${conf[action]}" == "update" ]] || return
section " calculating changes "

g_current_commit="$(git log -1 --format="%H")"

echo "acquiring change set via:"

local new_files=""
if ${conf[fetch]}; then
    debug 1 "if fetch"
    if [[ "$g_old_commit" != "$g_current_commit" ]];then
        echo "git diff --name-only g_old_commit g_current_commit"
        echo "old: $g_old_commit"
        echo "new: $g_current_commit"
        new_files="$(git diff --name-only $g_old_commit $g_current_commit)"
        debug 2 "new files: $new_files"
    else
        echo "The commit has not changed!!"
    fi
elif ${conf[pull]};then
    debug 1 "if pull"
    echo "git diff - this collects only changes that are not already in the index or committed"
    local new_files_tmp="$(git diff --name-only)"
    new_files="$(grep -v -E "/po/.*\.po$|/INSTALL$" <<< "$new_files_tmp")"
    debug 2 "$new_files"
else
    echo "git diff - this collects only changes that are not already in the index or committed"
    local new_files_tmp="$(git diff --name-only)"
    new_files="$(grep -v -E "/po/.*\.po$|/INSTALL$" <<< "$new_files_tmp")"
    debug 2 "$new_files"

fi

echo "receiving paths"
local new_dirs="$(
    while read -r line; do
        echo "${line%/*}/"
    done <<< "$new_files"
)"

debug 1 sleep "new_dirs: $new_dirs"

echo "building path map"
local -A path_map
for pkg in $packages; do
    find_local_path "$pkg" "/trunk"
    local path="${conf[current_package_path]}"
    path=${path##"$src_path"}
    path_map["$pkg"]="trunk/$path/"
    debug 3 "map $pkg: ${path_map[$pkg]}"
done

packages_new=""
for pkg in $packages; do
    if [[ "${path_map[$pkg]}" ]]; then
        if echo $new_dirs | grep -q -E  "${path_map[$pkg]}.*" ; then
            packages_new+="$pkg "
        fi
    fi
done

#
# TODO - parse information about failed packages here!!!
#
packages="$packages_new"
if [[ "$packages" ]]; then
    echo "The following packages are not up to date: "
    echo_long "$packages"
else
    echo "All packages are up to date! There is no need to update!!"
    exit 0
fi
} #}}}

add_failed(){
debug 1 "$FUNCNAME() $*"
# add failed packages to packages that should be build
section " looking for failed packages "
echo "not implemented"
}

pkg_failed(){
debug 1 "$FUNCNAME() $*"
# add to failed
echo "Adding $1 to failed list/file/conf entry wahtever (not implemented)"
}

pkg_success(){
debug 1 "$FUNCNAME() $*"
# remove from failed
:
}
ignore_pkgs(){
debug 1 "$FUNCNAME() $*"
[[ "${conf[ignore]}" ]] || return
section " ignore packages "
local ignore=${conf[ignore]//,/ }
echo "ignoring packages $ignore"
packages="$(sub_lists "$packages" "$ignore")"
}

### set up the build environment
set_env(){ #{{{
debug 1 "$FUNCNAME() $*"
local install_path="${conf[install_path]}"

section "setting env variables "

export PATH="$install_path/bin:$PATH"
echo "PATH=$PATH"
export ACLOCAL_FLAGS="-I $install_path/share/aclocal $ACLOCAL_FLAGS"
echo "ACLOCAL_FLAGS=$ACLOCAL_FLAGS"
export LD_LIBRARY_PATH="$install_path/lib:$LD_LIBRARY_PATH"
echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$install_path/lib/pkgconfig:$PKG_CONFIG_PATH"
echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
export CPPFLAGS="$CPPFLAGS -I$install_path/include"
echo "CPPFLAGS=$CPPFLAGS"
export LDFLAGS="$LDFLAGS -L$install_path/lib ${conf[ldflags]}"
echo "LDFLAGS=$LDFLAGS"
export CFLAGS="$CFLAGS ${conf[cflags]}"
echo "CFLAGS=$CFLAGS"
export PYTHONPATH="$(python -c "import distutils.sysconfig; print distutils.sysconfig.get_python_lib(prefix='$install_path')" 2>/dev/null)"
echo "PYTHONPATH=$PYTHONPATH"
export PYTHONINCLUDE="$(python -c "import distutils.sysconfig; print distutils.sysconfig.get_python_inc(prefix='$install_path')" 2>/dev/null)"
echo "PYTHONINCLUDE=$PYTHONINCLUDE"
export NOCONFIGURE="true"
echo "NOCONFIGURE=$NOCONFIGURE"
echo

if ${conf[verbose]}; then
    sleep 5
fi

echo 'checking existence of $install_path/share/aclocal $PYTHONPATH $PYTHONINCLUDE ... '
local failed=false
for dir in "$install_path/share/aclocal" "$PYTHONPATH" "$PYTHONINCLUDE"; do
    if [[ ! -w "$dir" ]]; then
        if ! mkdir -p "$dir"; then
            echo
            echo "please create the $dir as root and allow you user to wirte to it"
            echo "sudo mkdir -p $dir"
            echo "sudo chown $USER:$USER $dir"
            failed=true
        fi
    fi
done
## TODO ## OUTPUT
$failed && exit 1
} #}}}

### build
### calls: find_local_path, compile
build(){ #{{{
debug 1 "$FUNCNAME() $*"
#
# This functions should find the
#
section " entering build phase "
echo -e "The following packages will be build:\n"
echo_long "$packages"
echo

for pkg in $packages; do
    msg "- trying to build $pkg ..."

    #initialize vars
    debug 2 "init vars"
    g_current_failed=false
    conf[current_package_path]=""

    #find src
    find_local_path "$pkg" "/trunk"
    local cpath="${conf[current_package_path]}"
    local bpath="${conf[build_path]}"
    if [[ -z "$cpath" ]]; then
        nerr "source path of of package $pkg not found"
        msg_ani "SKIP"
        continue
    else
        #for animation
        ${conf[animate]} && write_appname "$pkg"

        fix_pkg "$pkg" "$cpath" "/trunk" "$bpath"

      ###compile it!
        declare -g g_retry=true
        while $g_retry; do
            g_retry=false
            compile "$pkg" "$cpath" "/trunk" "$bpath"
            #for animation
            if $g_current_failed && ${conf[animate]}; then
                msg_ani "FAILED"
                pkg_err $pkg "Failed to build $pkg"
                $g_retry && write_appname "$pkg"
            fi
        done
      ####

      #### management of failed / successful packages
        if $g_current_failed; then
            #
            # ADD PKG TO FAILED
            pkg_failed "$pkg"
        else
            # REMOVE PKG FROM FAILED
            pkg_success "$pkg"
            #for animation
            msg_ani "OK"
        fi
    fi
done

[[ $packages_failed ]] && echo "The following packages failed to build: $packages_failed"
} #}}}

### find the source code of a package
find_local_path (){ #{{{
debug 1 "$FUNCNAME() $*"
#
# Function that should find the source path to the current package
#
# In:
# $1 - package name
# $2 - trunk
# Out:
# sets: conf[current_package_path]
#
local name="$1"
local trunk="$2"
local path=""
local src_path="${conf[src_path]}${trunk}"

conf[current_package_path]="$path"

#prune dirs to ignore
local prune=""
for dir in devs DOCS E16 EXAMPLES TEST web packaging; do
    prune="-o -path $src_path/$dir $prune"
done
prune=${prune#-o}

#use find to get possible dirs
#debug-x
dirs="$(find "$src_path" -maxdepth 3 -type d \( $prune \) -prune -o -type d -name "$name" -printf "%P\n" )"
#debug+x
debug 2 "$dirs"

#pick the one with the sortest path
local path_len=666
while read -r path ;do
    if [[ -d "$src_path/$path" ]] && (( ${#path} < $path_len ));  then
        conf[current_package_path]="$path"
        path_len=${#path}
    fi
done <<< "$dirs"
debug 1 "path selected for $pkg: $src_path/${conf[current_package_path]}"

if [[ -z "${conf[current_package_path]}" ]] ; then
    nerr "Source path for $pkg was not found!"
fi
} #}}}

### sets up configure parameters
### calls: run_cmd
compile(){ #{{{
debug 1 "$FUNCNAME() $*"
local pkg="$1"
local src_path="$2"
local src_off="$3"
debug 1 "package: $pkg"
local src_path="${conf[src_path]}${src_off}/$src_path"
debug 1 "srcpath: $src_path"
local build_path="${conf[build_path]}/$1"
debug 1 "build_path: $build_path"

g_current_failed=false

local install_path="${conf[install_path]}"
local pkg_conf_args="${conf["${pgk}_conf_args"]}"
local build_type=""
local log_file="${conf[log_path]}/$pkg.log"
[[ -e "$log_file" ]] && rm "$log_file"

# find type of build process
if   [ -e "$src_path/autogen.sh" ];
    then build_type="autogen"
elif [ -e "$src_path/bootstrap" ];
    then build_type="bootstrap"
elif [ -e "$src_path/Makefile.PL" ];
    then build_type="perl"
elif [ -e "$src_path/Makefile" ]; then
    build_type="make"
    export PREFIX="${conf[install_path]}"
elif [ -e "$src_path/setup.py" ];
    then build_type="python"
else
    export PREFIX=""
fi

debug 1 "Type of build system $build_type"

declare -g g_clean_phase=true
case "$build_type" in
    autogen|bootstrap)
        ${conf[clean]}     && run_cmd "$pkg" "$src_path" "$build_path" "make clean"     "make clean"
        g_current_failed=false
        ${conf[distclean]} && run_cmd "$pkg" "$src_path" "$build_path" "make distclean" "make distclean"
        g_current_failed=false
        ${conf[uninstall]} && run_cmd "$pkg" "$src_path" "$build_path" "make uninstall" "make uninstall"
        g_current_failed=false
        ;;&
    make|perl)
        ${conf[clean]}     && run_cmd "$pkg" "$src_path" "" "make clean"     "make clean"
        g_current_failed=false
        ${conf[uninstall]} && run_cmd "$pkg" "$src_path" "" "make uninstall" "make uninstall"
        g_current_failed=false
        ;;
    *)
        :
        ;;
esac
g_clean_phase=false
g_current_failed=false

#use the power of ;;& - muahahh
#UGLY HACK!!
  case "$build_type" in
      autogen)
          run_cmd "$pkg" "$src_path" "" "autogen" "./autogen.sh"
          ;;&
      bootstrap)
          run_cmd "$pkg" "$src_path" "" "boostrap" "./bootstrap"
          ;;&
      perl)
          run_cmd "$pkg" "$src_path" "$build_path" "perlmake" "perl $src_path/Makefile.PL prefix=$install_path"
          ;;&
      autogen|bootstrap) #configure
          $g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "configure" "$src_path/configure --prefix=$install_path $pgk_conf_args"
          ;;&
      autogen|bootstrap|perl) # make && make install
        $g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "make" "make -j ${conf[threads]}"
        $g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "install" "make install"
          ;;
      make) # make && make install
        run_cmd "$pkg" "$src_path" "" "make" "$make_extra make -j ${conf[threads]}"
        $g_current_failed || run_cmd "$pkg" "$src_path" "" "install" "make install"
          ;;
      python)
        run_cmd "$pkg" "$src_path" "" "setup.py-build" "python setup.py build build_ext --include-dirs=$PYTHONINCLUDE $pkg_conf_args"
        $g_current_failed || run_cmd "$pkg" "$src_path" "" "setip-py-install" "python setup.py install --prefix=$install_path install_headers --install-dir=$PYTHONINCLUDE"
          ;;
      *)
          msg echo "no build system found"
          msg_ani -n " (no build system) - "
          g_current_failed=true
          return
  esac

} #}}}

### runs the commands that are actually used to build the code
### calls: rotate
run_cmd(){ #{{{
debug 1 "$FUNCNAME() $*"
#
# In:
# $1 - pkg - package name
# $2 - src - source path
# $3 - build - path in which configure will be run
# $4 - title - titel of the displayed action while the command is running
# $@ - the command to be run
#
# Out:
# compiles the code and sets g_current_failed in case of failure
#
# FUNCTION NEEDS TO BE REWRITTEN - it is UGLY and STUIP
# a better way than writing $@ to call the command would be nice
#
# the 3 different calls might be handled in another way
# maybe it is better to write a separate run_animated function
#

local pkg="$1"
local src="$2"
local build_path="$3"
local title="$4"
shift 4

if [[ -n "$build_path" ]]; then
    #clean it whatever it means
    mkdir -p "$build_path" || on_error "unable to create $build_path"
    cd "$build_path" || on_error "unable to cd into $build_path"
else
    cd "$src" || on_error "unable to cd into $src"
fi


## check if makefile is available
if [[ $title == "make"* ]]; then
    if ! [[ -e Makefile || -e makefile ]]; then
    #TODO - elif check source dir and cd into it
        g_current_failed=true
        #We will not fail in clean_phase
        ${conf[animate]} && return
        msg -n "  - $title ... "
        if $g_clean_phase; then
            msg  "FAILED - make may fail during clean phase"
        else
            msg  "FAILED"
            nerr "No makefile - failed to build $pkg"
        fi
        return
    fi
fi

log_file="${conf[log_path]}/$pkg.log"
debug 1 "running in path: $(pwd)"

echo -e "\n\ngit_e17 - $title \n$* \n\n" >>"$log_file"

#run only if pre checks did not fail
if ! $g_current_failed; then
    #if animation mode is used
    if ${conf[animate]}; then
        #call
        nice -n "${conf[nice]}" bash -c "$@" &>>"$log_file" &
        #get pid
        pid="$!"
        #start animation
        ( rotate "$pid" "${title}: " "$log_file" ) &
        #wait for command to finish and check exit status
        if ! wait $pid; then
            g_current_failed=true
        else
            #check log for errors
            if tail -n 20 "$log_file" | grep -q -i error &> /dev/null; then
                g_current_failed=true
            fi
        fi
        #wait for animation - is that necessary?
        wait
        # success
        #return here and now do not go any further - HACK!!!
        return
    #if a more verbose mode is used
    elif ${conf[verbose]} || ${conf[dev]} ; then
        echo -e "  - RUNNING: ${bold}$@${boldoff} ... "
        echo -e "         IN: $(pwd)\n"
        sleep 2
        if ! nice -n "${conf[nice]}" bash -c "$@" &> >(tee -a "$log_file"); then
            g_current_failed=true
        else
            if tail -n 20 "$log_file" | grep -q -i error &> /dev/null; then
                g_current_failed=true
            else
                echo
                return
            fi
        fi
    #if normal mode is used
    else
        msg -n "  - $title ... "
        if ! nice -n "${conf[nice]}" bash -c "$@" &>>"$log_file"; then
                g_current_failed=true
        else
            if tail -n 20 "$log_file" | grep -q -i error &> /dev/null; then
                g_current_failed=true
            else
                msg "OK"
                return
            fi
        fi
    fi
    msg "FAILED"
    echo
    tail -n 30 "$log_file"
    echo
    $g_clean_phase || pkg_err $pkg "Failed to build $pkg"
        :
fi #end of pre checks of
} #}}}


fix_pkg(){
debug 1 "$FUNCNAME() $*"
local pkg="$1"
local cpath="$2"
local coff="$3"
local bpath="$4"

cpath="${conf[src_path]}${coff}/$cpath"
bpath="$bpath/$pkg"

case $pkg in
    drawer|itask|winlist-ng|enlil|enki)
        msg -n "  - fixing ... "
        rsync -av "$cpath/" "$bpath/" &>/dev/null
        msg "PRAY!"
        ;;
esac
}


##### functions used in main }}}

#### distcheck functions {{{
distcheck(){
#echo -e "${bold}checking distribution ...${boldoff}"
debug 1 "$FUNCNAME() $*"
[[ "$@" != "check" ]] && return
section " build dependences check "

#check for programs
#find  distribution
if [ -e "/etc/debian_version" ]; then
    echo "found distribution debian"
    debian
elif [ -e "/etc/gentoo-release" ]; then
    echo "found distribution gentoo"
    unsupported_dist_note
elif [ -e "/etc/redhat-release" ]; then
    echo "found distribution gentoo"
    unsupported_dist_note
elif [ -e "/etc/SuSE-release" ]; then
    echo "found distribution gentoo"
    unsupported_dist_note
else
    echo "did not find your distribution"
    unsupported_dist_note
fi

echo "proceeding with general checks"
#
#   general check
#
local failed=false

deps_bin="git make automake byacc g++ gcc libtool pkg-config"
deps_dev="dbus-1 fontconfig freetype GL jpeg lua5.1 png rsvg-2 udev xml2 X11 Xext Xrandr xcb"

echo -e "checking commands:"
for bin in $deps_bin; do
    echo_padd 15 ' ' -n "$bin"
    if ! type $bin &> /dev/null; then
        failed=true
        echo "missing"
    else
        echo "ok"
    fi
done

echo -e "\n\nchecking includes:"
compfile="/tmp/include_test.c"
echo "main(){}" >$compfile
for dep in $deps_dev; do
    echo_padd 15 ' ' -n "$dep"
    if ! gcc -o /dev/null $compfile -l$dep &>/dev/null; then
        failed=true
        echo "include missing"
    else
        echo "ok"
    fi
done

$failed && echo "Please install the missing build dependencies" && exit 1
exit 0
}
##  debian specific stuff
debian(){
debug 1 "$FUNCNAME() $*"

#must be tested for stable
local deps_debian_common="git autoconf automake1.9 autotools-dev autoconf-archive gettext libtool libfreetype6-dev "
deps_debian_common+="libpng12-dev libtiff4-dev libgif-dev libbz2-dev libltdl-dev pkg-config libxine-dev build-essential flex bison byacc "
deps_debian_common+="libxcursor-dev libtag1-dev sqlite libxml2-dev libsqlite3-dev libxslt1.1 libxslt1-dev giblib1 "
deps_debian_common+="giblib-dev libtool libtagc0-dev libmpd1 libmpd-dev libxcomposite-dev libxcomposite1 libxdamage-dev "
deps_debian_common+="libxdamage1 libxkbfile-dev libxkbfile1 libxkbfile-dev libxkbfile1 libdbus-1-dev libtheora-dev libpopt-dev "
deps_debian_common+="libglib2.0-dev libfontconfig1-dev libxrandr-dev libasound2-dev libxinerama-dev cvs automake libgstreamer0.10-dev menu "
deps_debian_common+="menu-xdg xdg-utils liblua5.1-0-dev dbus-x11 libexif-dev mesa-common-dev libudev-dev cython "
deps_debian_common+="libxcb-shape0-dev python-dev libcanberra-dev libtuxcap-dev chipmunk-dev"

##TODO finish the lists
local stable="libpam-dev libiptcdata-dev libcurl4-gnutls-dev libsdl-dev "
local sid="libpam0g-dev libiptcdata0-dev libcurl4-openssl-dev libsdl1.2-dev"

## use this for now
local deps_debian_sid="$deps_debian_common $sid"

local pkg_list="$(dpkg -l)"
local missing=""

echo -e "\n ### This check should work for Debian wheezy/sid and Ubuntu precise ###"
echo -e "\ndependences:"
echo -e "$deps_debian_sid\n"

echo -en "\n\nchecking ... "
for dep in $deps_debian_sid; do
    if ! echo "$pkg_list" | grep -q -E "^ii\s*$dep" &>/dev/null ; then
        missing+="$dep "
    fi
    wait
done


if [[ $missing ]]; then
    echo -e "failed\n\nThe following packages are missing:\n${missing}\n"
    if (( $(id -u) == 0 )); then
        if [[ $(ask_yn "do you want to install the missing packages?") == "yes" ]]; then
            apt-get install $missing || exit 1
        fi
    else
        sleep 10
    fi
else
    echo ok
fi

}

unsupported_dist_note(){
echo "there are currently no checks for you distribution / OS available"
echo "please send me a patch or tell me which packages are required"
echo "and how to check their presence"
}

#### distcheck functions }}}

#### Helper functions {{{
inter_lists(){
#intersect list $1 and $2
local result=""
for list1_item in $1; do
    for list2_item in $2; do
        if [[ "$list1_item" == "$list2_item" ]]; then
            result+="$list1_item "
        fi
    done
done
}

# subtract 2nd list from first
sub_lists(){
local result=""
for list1_item in $1; do
    for list2_item in $2; do
        if ! [[ "$list1_item" == "$list2_item" ]]; then
            result+="$list1_item "
        fi
    done
done
}
sort_as_full(){
    #bring items in $@ in the same order as in $packages_full
    inter_lists "$packages_full" "$@"
}
## OUTPUT
write_bold(){ tput bold; echo "$@"; tput sgr0; }

msg(){ ${conf[animate]} || echo "$@"; }             #normal mode message - only when not animated

verbose(){ ${conf[verbose]} && echo -e "$@";}       #verbose message

msg_ani(){ ${conf[animate]} && echo "$@"; }         #animation mode message

# print scetion banner
section(){
    set -e
    local fill_symbol="-"
    local title="$@"

    local width=80
    local fill=$(( width-${#title} ))
    local rest=$(( fill % 2 ))
    fill=$(( fill / 2))
    #printf "$fill_symbol%.0s" {1..$(( fill + rem ))}  - fuck no
    for (( n=1 ; n <= fill ; n++ )); do echo -n "$fill_symbol" ; done
    tput bold
    echo -n "$title"
    tput sgr0
    for (( n=1 ; n <= (fill+rest) ; n++ )); do echo -n "$fill_symbol" ; done
    echo
    set +e
}

## print configuration
copy_cfg(){
unset g_old_conf
declare -g -A g_old_conf
for key in "${!conf[@]}"; do
    g_old_conf["$key"]="${conf["$key"]}"
done
}

print_cfg(){
local changed=false

local changes="$(
for item in "${!conf[@]}"; do
    if [[ "${conf["$item"]}" != "${g_old_conf["$item"]}" ]]; then
        echo "$item=${conf["$item"]}"
        changed=true
    fi
done)"

if [[ "$changes" ]]; then
    echo "The following Configuration items changed:"
    echo "$changes"
else
    echo "The configuration did not Change!"
fi

}

echo_padd(){
local len="$1"
local padd="$2"
local args=
shift 2
## get aditional arguments
while : ; do
    if [[ $1 == @(-n|-e|-ne) ]]; then
        args+=$1
        shift
    else
        break
    fi
done

msg="$@ "
#fill with padd
while (( ${#msg} < len-1 )); do
    msg+="$padd"
done
msg+=" "
#print
echo $args "$msg"
}

echo_long(){
    # breaks a long line in single lines that fit width
    # if the first argument is -f the second is inseted
    # in the beginning of the lines

    local fill=""
    if [[ "$1" == "-f" ]]; then
        fill="$2"
        shift 2
    fi
    # break output at width
    local line_out="$fill"
    local width=80
    for item in $@; do
        if (( (${#line_out} + ${#item})  > width )); then
            echo -ne "${line_out}\n"
            line_out="${fill}"
        else
            line_out+="$item "
        fi
    done
    echo -ne "${line_out}\n"
}

print_array(){
#call: print_array array[@]
declare -a array=("${!1}")
for item in "${array[@]}"; do
    echo "$item"
done
}

## ERROR
err(){ echo; echo -n "Error: "; echo "$@"; }
#fatal error
ferr(){ err "$@"; exit 1; }
#non fatal error

nerr(){
debug 1 "$FUNCNAME() $*"
[[ ${conf[on_error]} == "skip" ]] && return
g_current_failed=true
err "$@"
case ${conf[on_error]} in
    exit) exit 1 ;;
    ask)  local rv="$(ask_yn "The Program encountered an error - do you want to continue?")"; [[ "$rv" == "no" ]] && exit 1 ;;
esac
}

# ask to continue on error
ask_yn(){
while true; do
    read -p "$@ (y/n)" yn
    case "$yn" in
        [Yy]*) echo "yes"; break ;;
        [Nn]*) echo "no" ; break ;;
        *) echo "Please answer with yes or no." 1>&2 ;;
    esac
done
}

pkg_err(){
debug 1 "$FUNCNAME() $*"
[[ ${conf[on_error]} == "skip" ]] && return
g_current_failed=true
local pkg="$1"
shift
err "$@"
case ${conf[on_error]} in
    exit)
        #
        # ADD PGK TO FAILED
        pkg_failed "$pkg"
        exit 1
        ;;
    ask)
        while true; do
            read -p "$@ (y/n/retry) " yn
            case "$yn" in
                [Rr]*)
                    declare -g g_retry=true
                    break 1
                    ;;
                [Yy]*)
                    break
                    ;;
                [Nn]*)
                    #
                    # ADD PKG TO FAILED
                    pkg_failed "$pkg"
                    exit 1
                    ;;
                *) echo "Please answer with yes, no, retry." 1>&2 ;;
            esac
        done
        echo
        ;;
    *)
        ;;
esac
}


## helper debuging
debug(){
#
# This function displays debug information
# when the debug level set via command line
# is greater or equal the level passed to
# the function
#
# In:
# $1 - level
# $2 - message
#
${conf[debug]} || return
local action=""
local level="$1"
shift
if [[ "$1" == @(ask|sleep) ]]; then
    action="$1"
    shift
fi
msg="$@"

if (( level <= ${conf[debug_level]} )); then
    while read -r debug_line <&13; do
        echo "debug $level: $debug_line" 1>&2
    done 13<<< "$msg"
fi
[[ "$action" == "sleep" ]] && sleep 5
[[ "$action" == "ask" ]]   && read -p "press key to continue" -n 1
}

debug-x(){ ${conf[debug]} && set -x; }
debug+x(){ ${conf[debug]} && set +x; }

## debug configuration
debug_cfg(){
${conf[debug]} || return
echo
debug 4 "current configuration:"
for item in ${!conf[@]}; do
    debug 4 "$item=${conf["$item"]}"
done
echo
}



### fancy output functions
### taken from easy e17.sh - the code ist mostly unrevised:(
del_word(){
cnt=0
max=${#1}
while (( cnt < max )); do
    echo -n -e "\b \b"
    (( cnt++ ))
done
}

## TODO - rewrite
rotate ()
{
pid=$1
name="$2"
log_file=$3
animation_state=1
log_line=""
echo -n "$name"
echo -n "     "
while [[ "$(ps -p $pid -o comm=)" ]]; do
    last_line=$(tail -1 "$log_file")
    if [[ "$log_line" != "$last_line" ]]; then
                echo -e -n "\b\b\b\b\b"
                case $animation_state in
                    1)
                        echo -n "["
                        echo -n -e "\033[1m"
                        echo -n "\\o\\"
                        echo -n -e "\033[0m"
                        echo -n "]"
                        animation_state=2
                        ;;
                    2)
                        echo -n "["
                        echo -n -e "\033[1m|o|\033[0m"
                        echo -n "]"
                        animation_state=3
                        ;;
                    3)
                        echo -n "["
                        echo -n -e "\033[1m/o/\033[0m"
                        echo -n "]"
                        animation_state=4
                        ;;
                    4)
                        echo -n "["
                        echo -n -e "\033[1m|o|\033[0m"
                        echo -n "]"
                        animation_state=5
                        ;;
                    5)
                        echo -n "["
                        echo -n -e "\033[1m"
                        echo -n "\\o/"
                        echo -n -e "\033[0m"
                        echo -n "]"
                        animation_state=6
                        ;;
                    6)
                        echo -n "["
                        echo -n -e "\033[1m|o|\033[0m"
                        echo -n "]"
                        animation_state=1
                        ;;

                esac
        log_line=$last_line
    fi
    sleep 1
done
del_word "$name[|-|]"
}

function write_appname ()
{
    echo_padd 28 . -n "$@"
}

### END HELPER FUNCTIONS }}}

list(){ #{{{
debug 1 "$FUNCNAME() $*"
[[ ${conf[action]} == list ]] || return
section " list of available enlightenment packages "
echo
echo "not implemented"
echo

exit 0
} #}}}


default_global_cfg(){
#
# default content of ~/.git_e17
#
printf '%b\n' \
   "# git_e17 - global configuration file" \
   "#" \
   "# INFO:" \
   "# - local configurations and command line options override this file" \
   "# - lines starting with # are ignored" \
   "# - make sure your user has write access to all chosen paths" \
   "# - you are able to set the path outside the git e17 path" \
   "" \
   "# item=val - NO SPACES - NO QUOTES" \
   "" \
   "# default git_e17_path" \
   "git_e17_path=${conf[git_e17_path]%/}" \
   "# default config file" \
   "config_file=default.conf"
}

default_local_cfg(){
printf '%b\n' \
   "# git_e17 - local configuration file" \
   "#" \
   "# INFO:" \
   "# - lines starting with # are ignored" \
   "# - make sure your user has write access to all chosen paths" \
   "# - you are able to set the paths outside the git e17 directory" \
   "" \
   "# item=val - NO SPACES - NO QUOTES" \
   "" \
   "# this is the target dir of your installation" \
   "install_path=/usr/local/e17" \
   "# git repoistory directory" \
   "src_path=${conf[git_e17_path]}/e.org.git" \
   "# dir in which the" \
   "build_path=${conf[git_e17_path]}/build" \
   "log_path=${conf[git_e17_path]}/log" \
   "" \
   "# additional CFLAGS" \
   "cflags=-g" \
   "# additional LDFLAGS" \
   "#ldflags=" \
   "# clean \
   "#clean=false \
   "# packagelist to use basic, full" \
   "packagelist=full" \
   "# branch to checkout" \
   "#branch=master" \
   "# remote to pull from" \
   "#remote=origin" \
   "" \
   "# on on compile error action: ask,exit,continue" \
   "on_error=ask" \
   "# number ot threads" \
   "threads=8" \
   "#niceness level" \
   "nice=19" \
   "#create documentation" \
   "doc=false" \
   "" \
   "## extra configure flags" \
   "evas_conf_args=--enable-gl-x11"
}

### program starts here
# well it can be done as root
distcheck "$@"
# make sure main program ist not run as root as it cause serious damage
# i like to be sloppy - if you override this don't blame me:P
if [[ $(id -u) -eq 0 ]]; then
    echo "You should not run scripts as root! "
fi
main "$@"
