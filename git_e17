#!/usr/bin/env bash
# vim:expandtab:ts=4:sw=4:fdm=marker:fmr={{{,}}}
# To Inspect the code use vim, modelines and folds!!!!

#########################################################################
# This Scripts is based on Morlenxus' easy_e17.sh                       #
# It shares some of it's ideas as well as some code.                    #
# The original script can be found at:                                  #
# http://omicron.homeip.net/projects/#easy_e17.sh                       #
#                                                                       #
# Licebse: BSD licence                                                  #
# Get the lastes version at: https://github.com/ObiWahn/git_e17         #
# Coded by Jan Christoph Uhde (linux@obiwahn.org)                       #
#########################################################################

### global variable definitions {{{
efl_basic="eina eet evas ecore efreet eio eeze e_dbus embryo edje azy ethumb elementary"
efl_extra="imlib2 emotion enlil libast python-evas python-ecore python-e_dbus python-edje python-emotion python-elementary shellementary"
bin_basic="exchange e"
bin_extra="e_cho e-type e_phys eblock econcentration editje eenvader.fractal elsa emote empower enjoy enki ephoto eskiss Eterm expedite exquisite eyelight rage terminology"
e_modules_efl="libeweather"
e_modules_bin="emprint exalt"
e_modules_extra="alarm calendar comp-scale cpu deskshow diskio drawer eektool elfe empris engage eooorg everything-aspell everything-mpris everything-pidgin everything-places everything-shotgun everything-skeleton everything-tracker everything-wallpaper everything-websearch eweather exalt-client exebuf execwatch flame forecasts iiirk itask mail mem moon mpdule net news penguins photo places quickaccess rain screenshot skel slideshow snow taskbar tclock uptime weather winlist-ng winselector wlan"
e_themes="darkness detourious efenniht"

packages_basic="$efl_basic $bin_basic $e_themes"
packages_half="$efl_basic $bin_basic $e_themes $e_modules_efl $e_modules_bin $e_modules_extra"
packages_full="$efl_basic $bin_basic $e_themes $e_modules_efl $e_modules_bin $e_modules_extra $efl_extra $bin_extra"

declare -A conf

packages=""
packages_failed=""
g_current_commit=""
g_current_branch=""
g_old_commit=""

# signales return status of some operations as
# we lack proper return values
g_current_failed=false

conf[dev]=false
conf[verbose]=false
conf[debug]=false
conf[debug_level]=10
conf[animate]=false

#for use in errors
e="\n       "

bold=$(tput bold)
boldoff=$(tput sgr0)

conf[git_repo]=http://git.enlightenment.fr/cgit.cgi/svn.git/

###end global vars }}}
#### main function {{{
main(){
debug 1 "${FUNCNAME[0]}()"

## interpret command line
get_opts "$@"
## configuration
get_git_e17_path_from_global_cfg
read_local_cfg
read_global_cfg
assign_defaults
interpret_action
check_cfg
## source
get_src
git_fetch_reset
git_pull
## finding changes
calculate_updates
##
set_env
build
}
#### end main function }}}

##### functions used in main {{{
### display help - help(), devhelp() {{{
help(){
debug 1 "${FUNCNAME[0]}()"
#
# This functions displays the help file
#
cat << EOF

git_e17 - simple script for building enlightenment 17

git-e17 [options] action [only <packagelist>]

actions:
    build
        build everything
    update
        update your e17 to the latest version
        (git_e17 --animate --skip-errors --remote origin --fetch-reset-hard devupdate)
    fromscratch
        delete e17 installation and build e17 from scratch
        ATTENTION: this will rm -fr $install_path
                   do not do is if you installed to /usr/local
    list
        list all available packages (TODO with description)
only:
    use only named packages

options:
    -h | --help  / --dev-help
        show help / developer help
            developer help will give you some more options
    --git-e17-path
        workdir for this script. It will contain the source, config and log
        files and dirs in which e17 is build. The default git_e17_path sould
        be set in ~/.git_e17
    -s | --skip-errors
        skip non fatal errors
    -a | --animate
EOF
}
devhelp(){
debug 1 "${FUNCNAME[0]}()"
#
# This functions displays the developer help file
#
cat << EOF

extra actions:
    devupdate
        almost the same as update but does not imply --fetch-reset-hard

extra options:
    --conf <conf>
        config file - especially useful if you want multiple installs
        ONLY CONF NAME - NO FULL PATHS!!!
    -b | --branch <branch>
        branch, tag or commit to use
    -r | --remote <remote>
        select remote pull/fetch
    -p | --pull
        does a git pull --no-commit
    -f | --fetch-reset-hard
        ATTENTION: this will delete your local changes!!!!
        fetchs update from remote finds out your current branch
        and will do a git reset --hard remote/currentbrach

    --clean / --distclean
        make clean / distclean before building
    --vmake
        more verbse make (V=1)
    --conf_args
        extra configure args - for all packages
    -v | --verbose
    -d | --debug
        enable script debugging mode
EOF
}
### end help }}}

### parse command line
get_opts(){ #{{{
debug 1 "${FUNCNAME[0]}()"
section " reading command line options "
#
# This function reads the command line arguments
#
# In:
# $@ - ARGV
#
# Out:
# sets: conf, branch, debug, verbose or calls help
#
# TODO - idiot proof checking of arguments
#

while :
do
    case $1 in
        --git-e17-path)
            conf[git_e17_path]="$2"
            echo "found option: --git-e17-path $2"
            shift 2
            ;;
        -c|--conf)
            conf[config_file]="$2"
            echo "found option: --conf $2"
            shift 2
            ;;
        -b|--branch)
            conf[branch]="$2"
            echo "found option: --branch $2"
            shift 2
            ;;
        -r|--remote)
            conf[remote]="$2"
            echo "found option: --remote $2"
            shift 2
            ;;
        -p|--pull)
            conf[pull]=true
            echo "found option: --pull"
            shift
            ;;
        -f|--fetch-reset-hard)
            conf[fetch]=true
            echo "found option: --fetch-reset-hard"
            shift
            ;;
        -s|--skip-errors)
            conf[on_error]=skip
            echo "found option: --skip-errors"
            shift
            ;;
        -a|--animate)
            conf[animate]=true
            conf[debug]=false
            conf[verbose]=false
            echo "found option: --animate"
            shift
            ;;
        -d|--debug)
            conf[debug]=true
            conf[animate]=false
            conf[verbose]=true
            conf[debug_level]=4
            echo "found option: --debug"
            shift
            ;;
        -v|--verbose)
            conf[verbose]=true
            conf[animate]=false
            echo "found option: --verbose"
            shift
            ;;
        -h|--help)
            echo ""
            help
            echo "found option: --help"
            exit 0
            ;;
        --dev-help)
            echo ""
            help
            devhelp
            echo "found option: --dev-help"
            exit 0
            ;;
        *) #no more options beakb
            break
            ;;
    esac
done

#parse action parameter
debug 1 "action: $1"
if [[ "$1" == @(build|update|devupdate|fromscratch|list) ]]; then
    conf[action]="$1"
    echo "selected action is ${conf[action]}"
    shift
else
    devhelp
fi

if [[ "$1" == only ]]; then
    shift
    packages="$@"
    echo "only: $packages"
fi

debug_cfg
} #}}}

### get git_e17_path form ~/.git_e17 || create the file
get_git_e17_path_from_global_cfg(){ #{{{
debug 1 "${FUNCNAME[0]}()"
section "reading global configuration in ~/.git_e17"
#
# Read parts of the gobal config
#   This function tries to read the gloabl configuration file
#   or creates it. If the file existes two important config
#   items are read when they are not set by commandline
#
# Out:
#   sets: conf[git_e17_path], conf[config_file]
#
debug 1 "git e17 path: $1"
if [[ ! -f $HOME/.git_e17 ]]; then
    cat > "$HOME/.git_e17" << EOF
# git_e17 - global configuration file
#
# INFO:
# - local configurations and commandline options override this file
# - lines starting with # are ignored
# - make sure your user has write access to all choosen paths
# - you are able to set the path outside the git e17 path

# item=val - NO SPACES - NO QUOTES

# default git_e17_path
git_e17_path=${conf[git_e17_path]%/}
# default config file
config_file=default.conf
EOF
    if [[ ! ${conf[git_e17_path]} ]]; then
        echo -e "\nPlease edit your fresh created ~/.git_e17\nand add the path to the default git e17 path."
    fi
fi

#read config values git_e17_path and config_file
while IFS='=' read -r item value; do
    if [[ "$item" == @(git_e17_path|config_file) ]]; then
        conf["$item"]=${conf["$item"]:-"$value"}
        debug 3 "conf[$item]=$value"
    fi
done <<< "$(grep -v ^# "$HOME/.git_e17" | grep -v ^$ )"

#final check if path is set
debug 2 "The git e17 path must be set by now!! git_e17_path=${conf[git_e17_path]}"
if [[ ! ${conf[git_e17_path]} ]]; then
    local out="git_e17_path is not set:("
          out="$out${e}please set it via commandline or ~/.git_e17"
    ferr -e "$out"
fi

#remove trailing slash from git_e17_path
conf[git_e17_path]=${conf[git_e17_path]%/}

echo "git e17 path set to ${conf[git_e17_path]}"
echo "config file set to ${conf[config_file]}"

#check if git_e17_path exists
if ! [[ -d "${conf[git_e17_path]}" && -w "${conf[git_e17_path]}" ]]; then
    if ! mkdir -p "${conf[git_e17_path]}"; then
        ferr -e "unable to create or access ${conf[git_e17_path]}"
    fi
fi


debug_cfg
} #}}}

### read configuration in git e17 directory
read_local_cfg(){ #{{{
debug 1 "${FUNCNAME[0]}()"
section " reading git-e17-path configuration file (${conf[config_file]}) "
#
# This function reads the config file and sets script variables
#
# Out:
# sets: ... a lot ...
#
#

local conf_file="${conf[git_e17_path]}/${conf[config_file]}"
if [[ ! -f "$conf_file" ]]; then
    #create default config
    cat > "$conf_file" << EOF
# git_e17 - local configuration file
#
# INFO:
# - lines starting with # are ignored
# - make sure your user has write access to all choosen paths
# - you are able to set the paths outside the git e17 directory

# item=val - NO SPACES - NO QUOTES

# this is the target dir of your installation
install_path=/usr/local/e17
# git repoistory directory
src_path=${conf[git_e17_path]}/e.org.git
# dir in which the
build_path=${conf[git_e17_path]}/build
log_path=${conf[git_e17_path]}/log

# packetlist to use basic, full
packetlist=full
# branch to checkout
#branch=master
# remote to pull from
#remote=origin

# on on compile error action: ask,exit,continue
on_error=skip
# number ot threads
threads=8
#niceness level
nice=19
#create documentation
doc=false

## extra configure flags
evas_conf_args=--enable-gl-x11

EOF

    #end of default config
    echo -e "\nYou should edit Your new config in: \n$conf_file"
    exit 0
else
    # read config
    config="$(grep -v ^# < "$conf_file" | grep -v ^$)"
    debug 3 "$config"
    while IFS='=' read -r item value; do
        conf["$item"]=${conf["$item"]:-"$value"}
    done <<< "$config"
fi
debug_cfg
} #}}}

### read rest of ~/.git_e17 - sets only overwrite unset options
read_global_cfg(){ #{{{
debug 1 "${FUNCNAME[0]}()"
section " reading global cfg options "
#
# add global configuration
#
debug 1 "${FUNCNAME[0]}()"
    config="$(grep -v ^# < "$HOME/.git_e17" | grep -v ^$)"
    debug 3 "$config"
    while IFS='=' read -r item value; do
        conf["$item"]=${conf["$item"]:-"$value"}
    done <<< "$config"
debug_cfg
}
### assign default values
assign_defaults(){
debug 1 "${FUNCNAME[0]}()"
section " assigning default vaules  "

conf[log_path]="${conf[log_path]:-"${conf[git_e17_path]}/log"}"
conf[packagelist]="${conf[packagelist]:-"full"}"
conf[on_error]="${conf[on_error]:-"ask"}"
conf[nice]="${conf[nice]:-"19"}"
conf[pull]=${conf[pull]:-false}
conf[fetch]=${conf[fetch]:-false}
conf[remote]="${conf[remote]:-"origin"}"


if [[ ! $packages ]]; then
    case "${conf[packagelist]}" in
        full)  packages="$packages_full"  ;;
        half)  packages="$packages_half"  ;;
        basic) packages="$packages_basic" ;;
        *)     ferr "No valid package list packagelist=full|half|basic" ;;
    esac
fi

} #}}}

interpret_action(){
debug 1 "${FUNCNAME[0]}()"
local action="${conf[action]}"

case "$action" in
    build)
        conf[action]="build"
        conf[fetch]=false
        conf[pull]=false
        ;;
    update)
        conf[branch]="master"
        conf[remote]="origin"
        conf[fetch]=true
        conf[pull]=false
        conf[animate]=true
        conf[debug]=false
        conf[verbose]=false
        conf[on_error]="skip"
        ;;
    devupdate)
        conf[action]="update"
        ;;
    fromscratch)
        (( $(id -u) = 0 )) && echo "idiot!!!" && exit 666
        rm -fr "${conf[install_path]}"
        rm -fr "${conf[build_path]}"
        conf[fetch]=true
        ;;
    list)
        #TODO
        echo "not implemented"
        exit 1
        ;;

esac


}

### check for missing options and unwritable paths
check_cfg(){ #{{{
debug 1 "${FUNCNAME[0]}()"
#
# check configuration
#

## FIXME ##
conf[deto]="$HOME/.e/e/themes" ## FIX-FOR-A-THEME
local paths="deto install_path git_e17_path log_path src_path build_path log_path"
local output="debug debug_level dev verbose animate"
local conf_items="$paths $output action config_file packagelist nice on_error"

for item in $conf_items; do
    if [[ -z "${conf["$item"]}" ]]; then
        ferr "value for $item is not set - please edit your config file"
    fi
done

# check if directories are writeable
for path in $paths; do
    if [[ ! -d "${conf[$path]}" ]]; then
        mkdir -p "${conf[$path]}" && continue
        ferr "unable to create the directory ${conf[$path]} - create it!"
    elif [[ ! -w "${conf[$path]}" ]]; then
        ferr "The directory ${conf[$path]} is not writeable for you:( - change that!"
    fi
done

#translate strings to bool
for key in ${!conf[@]}; do
    case ${conf[key]} in
        true|yes) conf[key]=true ;;
        false|no) conf[key]=false ;;
        *) continue ;;
    esac
done
debug_cfg
} #}}}

### functions that scan source code and select packages to be build
### TODO SPLIT FUNCTION
get_src(){ #{{{
debug 1 "${FUNCNAME[0]}()"
section " getting source code "

g_current_failed=false
local src_path="${conf[src_path]}"
local git="${conf[git_repo]}"
local remote="${conf[remote]}"

#does the repo exist
if [[ ! -d ${conf[src_path]} ]]; then
    #create it
    echo "cloning ${conf[git_repo]}"
    git clone -v --progress "${conf[git_repo]}" "$src_path" || ferr "unable to clone repository"
fi
#change to repo
echo "changeing into $src_path"
cd "$src_path" || ferr "failed to cd in $src_path"

#get name of branch
g_current_branch="$(git symbolic-ref HEAD)"
g_current_branch="${g_current_branch##*/}"
echo "Your current branch is $g_current_branch"

#get hash of current HEAD
g_old_commit="$(git log -1 --format="%H")"
echo "You are at commit $g_old_commit"

} #}}}

git_fetch_reset(){ #{{{
debug 1 "${FUNCNAME[0]}() $@"
${conf[fetch]} || return
section " git fetch  "

local remote="${conf[remote]}"
local branch="${conf[branch]:-"$g_current_branch"}"

#select right branch
echo "checking out $branch so that you local $branch matchtes the remote branch"
echo "i think this is a good requirement to save the average person from harm:) "
if [[ -n "$branch" && "$branch" != "$g_current_branch" ]]; then
    if ! git checkout ${conf[branch]}; then
        ferr "unable to checkout selected branch - fix your repository"
    fi
fi

echo "git fetch $remote"
git fetch $remote | tee "${conf[git_e17_path]}/git.log" || nerr "git fetch"

git clean -f -d &> /dev/null
echo "git reset --hard  $remote/$branch"
git reset --hard "$remote/$branch" | tee "${conf[git_e17_path]}/git.log" || nerr "git reset --hard failed"

} #}}}

git_pull(){ #{{{
debug 1 "${FUNCNAME[0]}()"
${conf[pull]} || return
section " git pull --no-commit "
section " dear god we all hope there are no conflicts "
git pull --no-commit $remote | tee "${conf[git_e17_path]}/git.log" || nerr "git pull failed"
} #}}}

calculate_updates(){ #{{{
debug 1 "${FUNCNAME[0]}()"
[[ "${conf[action]}" == "update" ]] || return
section " calculating changes "

g_current_commit="$(git log -1 --format="%H")"

echo "acquiring change set via:"

local new_files=""
if ${conf[fetch]}; then
    debug 1 "if fetch"
    if [[ "$g_old_commit" != "$g_current_commit" ]];then
        echo "git diff --name-only g_old_commit g_current_commit"
        echo "old: $g_old_commit"
        echo "new: $g_current_commit"
        new_files="$(git diff --name-only $g_old_commit $g_current_commit)"
        debug 2 "new files: $new_files"
    else
        echo "The commit has not changed!!"
    fi

elif ${conf[pull]};then
    debug 1 "if pull"
    echo "git diff - this collects only changes that are not already in the index or committed"
    local new_files_tmp="$(git diff --name-only)"
    new_files="$(grep -v -E "/po/.*\.po$|/INSTALL$" <<< "$new_files_tmp")"
    debug 2 "$new_files"
else
    echo "git diff - this collects only changes that are not already in the index or committed"
    local new_files_tmp="$(git diff --name-only)"
    new_files="$(grep -v -E "/po/.*\.po$|/INSTALL$" <<< "$new_files_tmp")"
    debug 2 "$new_files"

fi

echo "receiving paths"
local new_dirs="$(
    while read -r line; do
        echo "${line%/*}/"
    done <<< "$(git diff --name-only $current_commit | sort -u )"
)"

debug 1 "new_dirs: $new_dirs"

echo "building path map"
local -A path_map
for pkg in $packages; do
    find_local_path "$pkg" "/trunk"
    local path="${conf[current_package_path]}"
    path=${path##"$src_path"}
    debug 3 "map $pkg: $path"
    path_map["$pkg"]="trunk/$path/"
done

packages_new=""
for pkg in $packages; do
    if [[ "${path_map[$pkg]}" ]]; then
        while read -r line; do
            if [[ "${path_map[$pkg]}" == "$line" ]]; then
                packages_new="${packages_new}$pkg "
                debug 4 "line: $line"
                debug 4 "map ${path_map[$pkg]}"
            fi
        done <<< "$new_dirs"
    fi
done

#
# TODO - parse information about failed packages here!!!
#
packages="$packages_new"
if [[ "$packages" ]]; then
    echo "The following packages are not up to date: "
    echo_long "$packages"
else
    echo "All packages are up to date! There is no need to update!!"
    exit 0
fi
exit
} #}}}

### set up the build environment
set_env(){ #{{{
debug 1 "${FUNCNAME[0]}()"
local install_path="${conf[install_path]}"

section "setting env variables ..."

export PATH="$install_path/bin:$PATH"
echo "PATH=$PATH"
export ACLOCAL_FLAGS="-I $install_path/share/aclocal $ACLOCAL_FLAGS"
echo "ACLOCAL_FLAGS=$ACLOCAL_FLAGS"
export LD_LIBRARY_PATH="$install_path/lib:$LD_LIBRARY_PATH"
echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$install_path/lib/pkgconfig:$PKG_CONFIG_PATH"
echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
export CPPFLAGS="$CPPFLAGS -I$install_path/include"
echo "CPPFLAGS=$CPPFLAGS"
export LDFLAGS="$LDFLAGS -L$install_path/lib"
echo "LDFLAGS=$LDFLAGS"
export CFLAGS="$CFLAGS"
echo "CFLAGS=$CFLAGS"
export PYTHONPATH="$(python -c "import distutils.sysconfig; print distutils.sysconfig.get_python_lib(prefix='$install_path')" 2>/dev/null)"
echo "PYTHONPATH=$PYTHONPATH"
export PYTHONINCLUDE="$(python -c "import distutils.sysconfig; print distutils.sysconfig.get_python_inc(prefix='$install_path')" 2>/dev/null)"
echo "PYTHONINCLUDE=$PYTHONINCLUDE"
export NOCONFIGURE="true"
echo "NOCONFIGURE=$NOCONFIGURE"

echo 'checking existence of $install_path/share/aclocal $PYTHONPATH $PYTHONINCLUDE ... '
local failed=false
for dir in "$install_path/share/aclocal" "$PYTHONPATH" "$PYTHONINCLUDE"; do
    if [[ ! -w "$dir" ]]; then
        if ! mkdir -p "$dir"; then
            echo
            echo "please create the $dir as root and allow you user to wirte to it"
            echo "sudo mkdir -p $dir"
            echo "sudo chown $USER:$USER $dir"
            failed=true
        fi
    fi
done
## TODO ## OUTPUT
$failed && exit 1
} #}}}

### build
### calls: find_local_path, compile
build(){ #{{{
debug 1 "${FUNCNAME[0]}() $@"
#
# This functions should find the
#
section " entering build phase "
echo -e "The following packages will be build:\n"
echo_long "$packages"
echo

for pkg in $packages; do
    msg "- trying to build $pkg ..."

    #initialize vars
    debug 2 "init vars"
    g_current_failed=false
    conf[current_package_path]=""

    #find src
    find_local_path "$pkg" "/trunk"
    cpath=${conf[current_package_path]}
    if [[ -z "$cpath" ]]; then
        nerr "source path of of package $pkg not found"
        msg_ani "SKIP"
        continue
    else
        #for animation
        ${conf[animate]} && write_appname "$pkg"
        #compile it!
        compile "$pkg" "$cpath"
        if $g_current_failed; then
            packages_failed="$packages_failed $pkg"
            msg_ani "FAILED"
            # in other modes a more detailed report will be given
            ${conf[animate]} && nerr "Failed to build $pkg"
        else
            msg_ani "OK"
        fi
    fi
done

[[ $packages_failed ]] && echo "The following packages failed to build: $packages_failed"
} #}}}

### find the sourcecode of a pacakge
find_local_path (){ #{{{
debug 1 "${FUNCNAME[0]}() $@"
#
# Function that should find the source path to the current package
#
# In:
# $1 - package name
# $2 - trunk
# Out:
# sets: conf[current_package_path]
#
local name="$1"
local trunk="$2"
local path=""
local src_path="${conf[src_path]}${trunk}"

conf[current_package_path]="$path"

#prune dirs to ignore
local prune=""
for dir in devs DOCS E16 EXAMPLES TEST web packaging; do
    prune="-o -path $src_path/$dir $prune"
done
prune=${prune#-o}

#use find to get possible dirs
#debug-x
dirs="$(find "$src_path" -maxdepth 3 -type d \( $prune \) -prune -o -type d -name "$name" -printf "%P\n" )"
#debug+x
debug 2 "$dirs"

#pick the one with the sortest path
local path_len=666
while read -r path ;do
    if [[ -d "$src_path/$path" ]] && (( ${#path} < $path_len ));  then
        conf[current_package_path]="$path"
        path_len=${#path}
    fi
done <<< "$dirs"
debug 1 "path selected for $pkg: $src_path/${conf[current_package_path]}"

if [[ -z "${conf[current_package_path]}" ]] ; then
    nerr "Source path for $pkg was not found!"
fi
} #}}}

### sets up configure parameters
### calls: run_cmd
compile(){ #{{{
debug 1 "${FUNCNAME[0]}() $@"
local pkg="$1"
debug 1 "package: $pkg"
local src_path="${conf[src_path]}/trunk/$2"
debug 1 "srcpath: $src_path"
local build_path="${conf[build_path]}/$1"
debug 1 "build_path: $build_path"
g_current_failed=false
local log_file="${conf[log_path]}/$pkg.log"

#delete old log file
[[ -e "$log_file" ]] && rm "$log_file"

local install_path="${conf[install_path]}"
local pkg_conf_args="${conf["${pgk}_conf_args"]}"
local build_type=""
unset PREFIX
if   [ -e "$src_path/autogen.sh" ];
    then build_type="autogen"
elif [ -e "$src_path/bootstrap" ];
    then build_type="bootstrap"
elif [ -e "$src_path/Makefile.PL" ];
    then build_type="perl"
elif [ -e "$src_path/Makefile" ]; then
    build_type="make"
	export PREFIX="${conf[install_path]}"
elif [ -e "$src_path/setup.py" ];
    then build_type="python"
fi

debug 1 "Type of build system $build_type"

#use the power of ;;& - muahahh
#UGLY HACK!!
case "$build_type" in
    autogen)
        run_cmd "$pkg" "$src_path" "" "autogen" "./autogen.sh"
        ;;&
    bootstrap)
        run_cmd "$pkg" "$src_path" "" "boostrap" "./bootstrap"
        ;;&
    perl)
        run_cmd "$pkg" "$src_path" "$build_path" "perlmake" "perl $src_path/Makefile.PL prefix=$install_path"
        ;;&
    autogen|bootstrap) #configure
        $g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "configure" "$src_path/configure --prefix=$install_path $pgk_conf_args"
        ;;&
    autogen|bootstrap|perl) # make && make install
        set -x
		$g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "make" "make -j ${conf[threads]}"
		$g_current_failed || run_cmd "$pkg" "$src_path" "$build_path" "install" "make install"
        ;;
    make) # make && make install
		run_cmd "$pkg" "$src_path" "" "make" "$make_extra make -j ${conf[threads]}"
		$g_current_failed || run_cmd "$pkg" "$src_path" "" "install" "make install"
        ;;
    python)
		run_cmd "$pkg" "$src_path" "" "setup.py-build" "python setup.py build build_ext --include-dirs=$PYTHONINCLUDE $pkg_conf_args"
		$g_current_failed || run_cmd "$pkg" "$src_path" "" "setip-py-install" "python setup.py install --prefix=$install_path install_headers --install-dir=$PYTHONINCLUDE"
        ;;
    *)
        msg echo "no build system found"
        msg_ani -n " (no build system) - "
        g_current_failed=true
        return
esac

} #}}}

### runs the commands that are actually used to build the code
### calls: rotate
run_cmd(){ #{{{
debug 1 "${FUNCNAME[0]}() $*"
#
# In:
# $1 - pkg - package name
# $2 - src - source path
# $3 - build - path in which configure will be run
# $4 - title - titel of the displayed action while the command is running
# $@ - the command to be run
#
# Out:
# compiles the code and sets g_current_failed in case of failure
#
# FUNCTION NEEDS TO BE REWRITTEN - it is UGLY and STUIP
# a better way than writing $@ to call the command would be nice
#
# the 3 different calls might be handled in another way
# maybe it is better to write a seperate run_animated function
#

local pkg="$1"
local src="$2"
local build_path="$3"
local title="$4"
shift 4

if [[ -n "$build_path" ]]; then
    #clean it whatever it means
    mkdir -p "$build_path" || on_error "unable to create $build_path"
    cd "$build_path" || on_error "unable to cd into $build_path"
else
    cd "$src" || on_error "unable to cd into $src"
fi

## check if makefile is available
if [[ ${tilte%% *} == make ]]; then
    if ! [[ -e Makefile || -e makefile ]]; then
    #TODO - elif check source dir and cd into it
        g_current_failed=true
        ${conf[animate]} && return
        msg "Failed"
        nerr "No makefile - failed to build $pkg"
    fi
fi

log_file="${conf[log_path]}/$pkg.log"
debug 1 "running in path: $(pwd)"

#run only if pre checks did not fail
if ! $g_current_failed; then
    #if animation mode is used
    if ${conf[animate]}; then
        #call
        nice -n "${conf[nice]}" $@ &>>"$log_file" &
        #get pid
        pid="$!"
        #start animation
        ( rotate "$pid" "${title}: " "$log_file" ) &
        #wait for command to finish and check exit status
        if ! wait $pid; then
            g_current_failed=true
        else
            #check log for errors
            if tail -n 20 "$log_file" | grep -s -i error &> /dev/null; then
                g_current_failed=true
            fi
        fi
        #wait for animation - is that necessary?
        wait
        # success
        #return here and now do not go any further - HACK!!!
        return
    #if a more verbose mode is used
    elif ${conf[verbose]} || ${conf[debug]} || ${conf[dev]} ; then
        msg -n "  - $title ... "
        verbose "running: nice -n ${conf[nice]} $@ 2>&1 | tee $log_file"
        if ! nice -n "${conf[nice]}" $@ 2>&1 | tee -a "$log_file"; then
            g_current_failed=true
        else
            if tail -n 20 "$log_file" | grep -s -i error &> /dev/null; then
                g_current_failed=true
            else
                msg "OK"
                return
            fi
        fi
    #if normal mode is used
    else
        msg -n "  - $title ... "
        verbose "running: nice -n ${conf[nice]} $@ &>$log_file"
        if ! nice -n "${conf[nice]}" $@ &>"$log_file"; then
                g_current_failed=true
        else
            if tail -n 20 "$log_file" | grep -s -i error &> /dev/null; then
                g_current_failed=true
            else
                msg "OK"
                return
            fi
        fi
    fi
    msg "FAILED"
    echo
    tail -n 30 "$log_file"
    echo
    nerr "Failed to build $pkg"
fi #end of prechecks of
} #}}}

##### functions used in main }}}

#### distcheck functions {{{
distcheck(){
#echo -e "${bold}checking distribution ...${boldoff}"
debug 1 "${FUNCNAME[0]}()"
[[ "$@" != "distcheck" ]] && return
#check for programs
#find  distribution
distribution="debian"
case $distribution in
    debian) debian ;;
    *) : ;;
esac
exit 0
}
##  debian specific stuff
debian(){
debug 1 "${FUNCNAME[0]}()"
#dpkg -l check packages
#ask to install dpkgs
}
#### distcheck functions }}}

#### Helper functions {{{
inter_lists(){
    #intersect list $1 and $2
    local result=""
    for list1_item in $1; do
        for list2_item in $2; do
            if [[ "$list1_item" == "$list2_item" ]]; then
                result="$result $list1_item"
            fi
        done
    done
}

sort_as_full(){
    #bring items in $@ in the same order as in $packages_full
    inter_lists "$packages_full" "$@"
}
## OUTPUT
write_bold(){ tput bold; echo "$@"; tput sgr0; }

msg(){ ${conf[animate]} || echo "$@"; }             #normal mode message - only when not animated

verbose(){ ${conf[verbose]} && echo -e "$@";}       #verbose message

msg_ani(){ ${conf[animate]} && echo "$@"; }         #animation mode message

# print scetion banner
section(){
    set -e
    local fill_symbol="-"
    local title="$@"

    local width=80
    local fill=$(( width-${#title} ))
    local rest=$(( fill % 2 ))
    fill=$(( fill / 2))
    #printf "$fill_symbol%.0s" {1..$(( fill + rem ))}  - fuck no
    for (( n=1 ; n <= fill ; n++ )); do echo -n "$fill_symbol" ; done
    tput bold
    echo -n "$title"
    tput sgr0
    for (( n=1 ; n <= (fill+rest) ; n++ )); do echo -n "$fill_symbol" ; done
    echo
    set +e
}

echo_long(){
    # breaks a long line in single lines that fit width
    # if the first argument is -f the second is inseted
    # in the beginning of the lines

    local fill=""
    if [[ "$1" == "-f" ]]; then
        fill="$2"
        shift 2
    fi
    # break output at width
    local line_out="$fill"
    local width=80
    for item in $@; do
        if (( (${#line_out} + ${#item})  > width )); then
            echo -ne "${line_out}\n"
            line_out="${fill}"
        else
            line_out="$line_out$item "
        fi
    done
    echo -ne "${line_out}\n"
}

print_array(){
#call: print_array array[@]
declare -a array=("${!1}")
for item in "${array[@]}"; do
    echo "$item"
done
}

## ERROR
err(){ echo; echo -n "Error: "; echo "$@"; }
#fatal error
ferr(){ err "$@"; exit 1; }
#non fatal error
nerr(){
debug 1 "${FUNCNAME[0]}() $@"
g_current_failed=true
[[ ${conf[on_error]} == "skip" ]] && return
err "$@"
case ${conf[on_error]} in
    exit) exit 1 ;;
    ask)  local rv="$(ask_to_con)"; [[ "$rv" == "no" ]] && exit 1 ;;
esac
}

# ask to continue on error
ask_to_con(){
while true; do
    read -p "The Programm encountered an error - do you want to continue? (y/n) " yn
    case "$yn" in
        [Yy]*) echo "yes"; break ;;
        [Nn]*) echo "no" ; break ;;
        *) echo "Please answer with yes or no." 1>&2 ;;
    esac
done
}

## helper debuging
debug(){
#
# This function displays debug information
# when the debug level set via commandline
# is greater or equal the level passed to
# the function
#
# In:
# $1 - level
# $2 - message
#
${conf[debug]} || return
level="$1"; msg="$2"
if (( level <= ${conf[debug_level]} )); then
    while read -r line; do
        echo "debug $level: $line" 1>&2
    done <<< "$msg"
fi
}

debug-x(){ ${conf[debug]} && set -x; }
debug+x(){ ${conf[debug]} && set +x; }

## debug configuration
debug_cfg(){
${conf[debug]} || return
echo
debug 4 "current configuration:"
for item in ${!conf[@]}; do
    debug 4 "$item=${conf["$item"]}"
done
echo
}



### fancy output functions
### taken from easy e17.sh - the code ist mostly unreviewed:(
## TODO - rewrite - some of them
del_word(){
cnt=0
max=${#1}
while (( cnt < max )); do
	echo -n -e "\b \b"
	(( cnt++ ))
done
}
rotate ()
{
pid=$1
name="$2"
log_file=$3
animation_state=1
log_line=""
echo -n "$name"
echo -n "     "
while [[ "$(ps -p $pid -o comm=)" ]]; do
    last_line=$(tail -1 "$log_file")
	if [[ "$log_line" != "$last_line" ]]; then
				echo -e -n "\b\b\b\b\b"
				case $animation_state in
					1)
						echo -n "["
						echo -n -e "\033[1m"
						echo -n "\\o\\"
						echo -n -e "\033[0m"
						echo -n "]"
						animation_state=2
						;;
					2)
						echo -n "["
						echo -n -e "\033[1m|o|\033[0m"
						echo -n "]"
						animation_state=3
						;;
					3)
						echo -n "["
						echo -n -e "\033[1m/o/\033[0m"
						echo -n "]"
						animation_state=4
						;;
					4)
						echo -n "["
						echo -n -e "\033[1m|o|\033[0m"
						echo -n "]"
						animation_state=5
						;;
					5)
						echo -n "["
						echo -n -e "\033[1m"
						echo -n "\\o/"
						echo -n -e "\033[0m"
						echo -n "]"
						animation_state=6
						;;
					6)
						echo -n "["
						echo -n -e "\033[1m|o|\033[0m"
						echo -n "]"
						animation_state=1
						;;

				esac
		log_line=$last_line
	fi
	sleep 1
done
del_word "$name[|-|]"
}
function write_appname ()
{
	name="$1"
	hidden=$2
	cnt="${#name}"
	max=28

	if [ "$hidden" ]; then
		c=-3
		while [ ! $c = $cnt ]; do
			echo -n " "
			c=$(($c+1))
		done
	else
		echo -n "- $name "
	fi

	while [ ! $cnt = $max ]; do
		echo -n "."
		cnt=$(($cnt+1))
	done
	echo -n " "
}

### END HELPER FUNCTIONS }}}

### programm starts here
# well it can be done as root
distcheck "$@"
# make sure main programm ist not run as root as it cause serious damage
# i like to be sloppy - if you override this don't blame me:P
if [[ $(id -u) -eq 0 ]]; then
    echo "You should not run scripts as root! "
fi
main "$@"
